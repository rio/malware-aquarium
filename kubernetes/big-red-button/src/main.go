package main

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"strconv"
	"time"
)

const (
	bindAddress        = ":8080"
	kubernetesEndpoint = "https://kubernetes.default.svc.cluster.local"
	basePath           = "apis/kubevirt.io/v1/namespaces"
)

var (
	buttonIsLive, _ = strconv.ParseBool(os.Getenv("BUTTON_IS_LIVE"))
	namespace       string
	httpClient      http.Client
	authToken       string

	kindsToDelete = []string{
		"virtualmachines",
		"virtualmachineinstancereplicasets",
	}
)

func main() {
	// clear some default flags
	log.SetFlags(0)

	log.Printf("timestamp=%s level=info event=starting", time.Now().Format(time.RFC3339Nano))

	if err := createHTTPClient(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to create http client\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	if err := readToken(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to read service account token\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	if err := readNamespace(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to read current namespace\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	http.HandleFunc("/press", redButton)

	if buttonIsLive {
		log.Printf("timestamp=%s level=warning event=\"BUTTON IS LIVE\"", time.Now().Format(time.RFC3339Nano))
	}

	log.Printf("timestamp=%s level=info event=listening address=%s namespace=%s\n", time.Now().Format(time.RFC3339Nano), bindAddress, namespace)

	http.ListenAndServe(bindAddress, nil)
}

func createHTTPClient() error {
	caCert, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
	if err != nil {
		return err
	}

	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	httpClient = http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs: caCertPool,
			},
		},
	}

	return nil
}

func readNamespace() error {
	namespaceBytes, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
	if err != nil {
		return err
	}

	namespace = string(namespaceBytes)
	if namespace == "" {
		return errors.New("namespace is empty")
	}

	return nil
}

func readToken() error {
	authTokenBytes, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/token")
	if err != nil {
		return err
	}

	authToken = string(authTokenBytes)
	if authToken == "" {
		return errors.New("authorization token is empty")
	}

	return nil
}

func redButton(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	dryRun, _ := strconv.ParseBool(r.URL.Query().Get("dry-run"))
	if !dryRun && !buttonIsLive {
		dryRun = true
	}

	log.Printf("timestamp=%s level=info event=\"button pressed\" source=%s dry-run=%v\n", time.Now().Format(time.RFC3339Nano), r.RemoteAddr, dryRun)

	for _, kind := range kindsToDelete {
		resources, err := listResources(kind)
		if err != nil {
			log.Printf("timestamp=%s level=error event=\"failed to fetch %s\" error=%s", time.Now().Format(time.RFC3339Nano), kind, strconv.Quote(err.Error()))
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		for _, resource := range resources {
			if err := deleteResource(kind, resource, dryRun); err != nil {
				log.Printf("timestamp=%s level=error event=\"failed to delete %s\" error=%s", time.Now().Format(time.RFC3339Nano), kind, strconv.Quote(err.Error()))
			}
		}
	}
}

func listResources(kind string) ([]string, error) {
	resourcePath := path.Join(basePath, namespace, kind)

	listRequest, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/%s", kubernetesEndpoint, resourcePath), nil)
	listRequest.Header.Set("authorization", fmt.Sprintf("Bearer %s", authToken))

	getResp, err := httpClient.Do(listRequest)
	if err != nil || getResp.StatusCode != http.StatusOK {
		return []string{}, err
	}

	listResponseStruct := struct {
		Items []struct {
			Metadata struct {
				Name string
			}
		}
	}{}

	if err := json.NewDecoder(getResp.Body).Decode(&listResponseStruct); err != nil {
		return []string{}, err
	}

	names := make([]string, len(listResponseStruct.Items))

	for i, responseItem := range listResponseStruct.Items {
		names[i] = responseItem.Metadata.Name
	}

	log.Printf("timestamp=%s level=info event=\"fetched %s\" count=%d\n", time.Now().Format(time.RFC3339Nano), kind, len(names))

	return names, nil
}

func deleteResource(kind, name string, dryRun bool) error {
	resourcePath := path.Join(basePath, namespace, kind, name)

	deleteRequest, _ := http.NewRequest(http.MethodDelete, fmt.Sprintf("%s/%s", kubernetesEndpoint, resourcePath), nil)
	deleteRequest.Header.Set("authorization", fmt.Sprintf("Bearer %s", authToken))

	if !dryRun {
		_, err := httpClient.Do(deleteRequest)
		if err != nil {
			return err
		}
	}

	log.Printf("timestamp=%s level=info event=\"resource deleted\" kind=%s name=%s namespace=%s dry-run=%v\n", time.Now().Format(time.RFC3339Nano), kind, name, namespace, dryRun)

	return nil
}
