package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"strconv"
	"time"

	"github.com/grafana/loki/pkg/logproto"
	"google.golang.org/grpc"
)

const (
	bindAddress        = ":8080"
	kubernetesEndpoint = "https://kubernetes.default.svc.cluster.local"
	basePath           = "apis/kubevirt.io/v1/namespaces"
	// tailQuery          = "{container=\"suricata\"} |= `severity` | json | alert_severity <= 2"
	tailQuery = "{container=\"suricata\"} |~ \"(Remote Desktop|Remote Connection|Remote Shell|remote-access)\""
)

var (
	buttonIsLive, _ = strconv.ParseBool(os.Getenv("BUTTON_IS_LIVE"))
	lokiEndpoint    = os.Getenv("LOKI_ENDPOINT")

	httpClient http.Client
	lokiClient logproto.QuerierClient
	namespace  string
	authToken  string

	kindsToDelete = []string{
		"virtualmachines",
		"virtualmachineinstancereplicasets",
	}
)

func main() {
	// clear some default flags
	log.SetFlags(0)

	log.Printf("timestamp=%s level=info event=starting", time.Now().Format(time.RFC3339Nano))

	if err := createHTTPClient(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to create http client\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	if err := createLokiClient(lokiEndpoint); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to create loki client\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	if err := readToken(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to read service account token\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	if err := readNamespace(); err != nil {
		log.Fatalf("timestamp=%s level=fatal event=\"failed to read current namespace\" error=%s", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
	}

	http.HandleFunc("/press", redButton)

	if buttonIsLive {
		log.Printf("timestamp=%s level=warning event=\"BUTTON IS LIVE\"", time.Now().Format(time.RFC3339Nano))
	}

	go watchForLog()

	log.Printf("timestamp=%s level=info event=listening address=%s namespace=%s\n", time.Now().Format(time.RFC3339Nano), bindAddress, namespace)
	http.ListenAndServe(bindAddress, nil)
}

func createLokiClient(endpoint string) error {
	if endpoint == "" {
		return errors.New("missing LOKI_ENDPOINT")
	}

	log.Printf("timestamp=%s level=info event=\"connecting to loki\" endpoint=%s", time.Now().Format(time.RFC3339Nano), endpoint)

	ctx, _ := context.WithTimeout(context.Background(), 20*time.Second)

	conn, err := grpc.DialContext(
		ctx,
		endpoint,
		grpc.WithBlock(),
		grpc.WithInsecure(),
	)
	if err != nil {
		return err
	}

	log.Printf("timestamp=%s level=info event=\"connected to loki\" endpoint=%s", time.Now().Format(time.RFC3339Nano), endpoint)

	lokiClient = logproto.NewQuerierClient(conn)

	return nil
}

func createHTTPClient() error {
	caCert, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
	if err != nil {
		return err
	}

	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	httpClient = http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs: caCertPool,
			},
		},
	}

	return nil
}

func readNamespace() error {
	namespaceBytes, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
	if err != nil {
		return err
	}

	namespace = string(namespaceBytes)
	if namespace == "" {
		return errors.New("namespace is empty")
	}

	return nil
}

func readToken() error {
	authTokenBytes, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/token")
	if err != nil {
		return err
	}

	authToken = string(authTokenBytes)
	if authToken == "" {
		return errors.New("authorization token is empty")
	}

	return nil
}

func redButton(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodGet {
		http.ServeFile(w, r, "index.html")
		return
	}

	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	dryRun, _ := strconv.ParseBool(r.URL.Query().Get("dry-run"))
	if !dryRun && !buttonIsLive {
		dryRun = true
	}

	if err := pressButton(r.RemoteAddr, dryRun); err != nil {
		log.Printf("timestamp=%s level=info event=\"button press failed\" error=%s\n", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func listResources(kind string) ([]string, error) {
	resourcePath := path.Join(basePath, namespace, kind)

	listRequest, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("%s/%s", kubernetesEndpoint, resourcePath), nil)
	listRequest.Header.Set("authorization", fmt.Sprintf("Bearer %s", authToken))

	getResp, err := httpClient.Do(listRequest)
	if err != nil || getResp.StatusCode != http.StatusOK {
		return []string{}, err
	}

	listResponseStruct := struct {
		Items []struct {
			Metadata struct {
				Name string
			}
		}
	}{}

	if err := json.NewDecoder(getResp.Body).Decode(&listResponseStruct); err != nil {
		return []string{}, err
	}

	names := make([]string, len(listResponseStruct.Items))

	for i, responseItem := range listResponseStruct.Items {
		names[i] = responseItem.Metadata.Name
	}

	log.Printf("timestamp=%s level=info event=\"fetched %s\" count=%d\n", time.Now().Format(time.RFC3339Nano), kind, len(names))

	return names, nil
}

func deleteResource(kind, name string, dryRun bool) error {
	resourcePath := path.Join(basePath, namespace, kind, name)

	deleteRequest, _ := http.NewRequest(http.MethodDelete, fmt.Sprintf("%s/%s", kubernetesEndpoint, resourcePath), nil)
	deleteRequest.Header.Set("authorization", fmt.Sprintf("Bearer %s", authToken))

	if !dryRun {
		_, err := httpClient.Do(deleteRequest)
		if err != nil {
			return err
		}
	}

	log.Printf("timestamp=%s level=info event=\"resource deleted\" kind=%s name=%s namespace=%s dry-run=%v\n", time.Now().Format(time.RFC3339Nano), kind, name, namespace, dryRun)

	return nil
}

func watchForLog() {
	tailer, err := lokiClient.Tail(context.Background(), &logproto.TailRequest{Query: tailQuery})

	if err != nil {
		log.Printf("timestamp=%s level=error event=\"tailing logs failed\" error=%v\n", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
		return
	}

	logMatched := false

	log.Printf("timestamp=%s level=info event=\"tailing logs\" query=%s\n", time.Now().Format(time.RFC3339Nano), strconv.Quote(tailQuery))

	for {
		logEntry, err := tailer.Recv()
		if err != nil {
			log.Printf("timestamp=%s level=error event=\"tailing logs failed\" error=%v\n", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
			return
		}

		for _, s := range logEntry.Stream.Entries {
			log.Printf("timestamp=%s event=\"log query matched\" line=%s\n", s.Timestamp.Format(time.RFC3339Nano), strconv.Quote(s.Line))

			logMatched = true
		}

		if logMatched {
			if err := pressButton("log match", !buttonIsLive); err != nil {
				log.Printf("timestamp=%s event=\"button press failed\" error=%s\n", time.Now().Format(time.RFC3339Nano), strconv.Quote(err.Error()))
			}
		}
	}
}

func pressButton(source string, dryRun bool) error {
	log.Printf("timestamp=%s level=info event=\"button pressed\" source=%s dry-run=%v\n", time.Now().Format(time.RFC3339Nano), source, dryRun)

	for _, kind := range kindsToDelete {
		resources, err := listResources(kind)
		if err != nil {
			return err
		}

		for _, resource := range resources {
			if err := deleteResource(kind, resource, dryRun); err != nil {
				return err
			}
		}
	}

	return nil
}
